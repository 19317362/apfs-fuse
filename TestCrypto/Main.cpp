#define _CRT_SECURE_NO_WARNINGS

#include <cstdio>
#include <ApfsLib/AesXts.h>
#include <ApfsLib/DiskStruct.h>
#include <ApfsLib/Util.h>
#include <ApfsLib/BlockDumper.h>
#include <ApfsLib/Crypto.h>
#include <ApfsLib/Sha256.h>

#include <iostream>

int TestDiskDecrypt(int argc, char *argv[])
{
	if (argc < 3)
	{
		printf("Syntax: %s input.img output.img\n", argv[0]);
		return -1;
	}

	FILE *fin;
	FILE *fout;
	AesXts aes;
	uint8_t block[0x1000];
	uint64_t blk;
	size_t rd;
	size_t off;

	fin = fopen(argv[1], "rb");
	if (fin == nullptr)
	{
		printf("Unable to open %s for input.\n", argv[1]);
		return -1;
	}

	fout = fopen(argv[2], "wb");
	if (fout == nullptr)
	{
		printf("Unable to open %s for output.\n", argv[2]);
		fclose(fin);
		return -1;
	}

#if 0
	rd = fread(block, 1, 0x1000, fin);
	{
		const APFS_Superblock_NXSB *sb = reinterpret_cast<const APFS_Superblock_NXSB *>(block);

		aes.SetKey(sb->container_guid.data, sb->container_guid.data);
	}
#else
	{
		// 1D C5 5E E0 DF F3 77 5F 91 02 27 68 03 D6 63 2C C5 12 17 B2 74 FC B3 CB 82 B2 09 39 DE DE 3F 96
		// uint8_t key_1[0x10] = { 0x1D, 0xC5, 0x5E, 0xE0, 0xDF, 0xF3, 0x77, 0x5F, 0x91, 0x02, 0x27, 0x68, 0x03, 0xD6, 0x63, 0x2C };
		// uint8_t key_2[0x10] = { 0xC5, 0x12, 0x17, 0xB2, 0x74, 0xFC, 0xB3, 0xCB, 0x82, 0xB2, 0x09, 0x39, 0xDE, 0xDE, 0x3F, 0x96 };
		// uint8_t key[0x10] = { 0x2A, 0x7F, 0x32, 0x34, 0xAC, 0x23, 0x45, 0x52, 0x87, 0x02, 0x95, 0xDE, 0x1C, 0x2C, 0x94, 0xCC };
		uint8_t key[0x20] = { 0x32, 0x69, 0xE7, 0x60, 0xA5, 0xAB, 0x10, 0xB6, 0x49, 0x0B, 0x8C, 0xCD, 0x77, 0x33, 0x9F, 0xFA, 0x0C, 0x35, 0x30, 0x40, 0xD8, 0xCF, 0x4E, 0x33, 0x27, 0xB8, 0xA4, 0xDA, 0x13, 0x1C, 0x99, 0x7F };

		aes.SetKey(key, key + 0x10);
	}
#endif

	fseek(fin, 0, SEEK_SET);

	blk = 0;

	BlockDumper bd(std::cout, 0x1000);

	while (true)
	{
		rd = fread(block, 1, 0x1000, fin);
		if (rd != 0x1000)
			break;

		if (IsEmptyBlock(block, 0x1000) || VerifyBlock(block, 0x1000))
		{
			blk += 8;
		}
		else
		{
			for (off = 0; off < 0x1000; off += 0x200)
			{
				aes.Decrypt(block + off, block + off, 0x200, blk);
				blk++;
			}

			/*
			if (VerifyBlock(block, 0x1000))
			{
				bd.DumpNode(block, (blk - 8) >> 3);
			}
			*/
		}

		fwrite(block, 1, 0x1000, fout);
	}

	fclose(fin);
	fclose(fout);

	return 0;
}

void TestBlobVerify()
{
	static const uint8_t blob_cookie[6] = { 0x01, 0x16, 0x20, 0x17, 0x15, 0x05 };
	static const uint8_t blob_key[8] = { 0x0C, 0x9F, 0x38, 0xD3, 0x69, 0xCB, 0x46, 0x63 };
	static const uint8_t data[0x4B] = {
		0xA3, 0x49,
		0x80, 0x01,
		0x00,
		0x81, 0x10,
		0x2A, 0x7F, 0x32, 0x34, 0xAC, 0x23, 0x45, 0x52, 0x87, 0x02, 0x95, 0xDE, 0x1C, 0x2C, 0x94, 0xCC,
		0x82, 0x08,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x3F, 0x5D,
		0x83, 0x28,
		0xA6, 0x74, 0x97, 0xBF, 0x76, 0xDA, 0xA2, 0xD0, 0x8D, 0xEB, 0x02, 0x8F, 0x37, 0x93, 0xF4, 0x07,
		0xF4, 0xAC, 0x6F, 0x8C, 0xA8, 0xF8, 0xA0, 0x98, 0x89, 0x93, 0x9A, 0x59, 0xAB, 0x2E, 0xF7, 0x33,
		0x80, 0x57, 0x87, 0x95, 0x32, 0x14, 0xAE, 0x84
	};
	SHA256 sha;
	uint8_t hmac_key[0x20];
	uint8_t mac[0x20];

	sha.Init();
	sha.Update(blob_cookie, 6);
	sha.Update(blob_key, 8);
	sha.Final(hmac_key);

	HMAC_SHA256(hmac_key, 0x20, data, 0x4B, mac);

	DumpHex(std::cout, mac, 0x20, 0x20);
}

void TestKeyDerivation()
{
	uint8_t wrapped_key_scer[0x28] =
	{
		0x25, 0xC8, 0x5C, 0x7E, 0xF8, 0x0A, 0x45, 0x37, 0x19, 0x59, 0x60, 0x17, 0x85, 0x0A, 0xB6, 0x31,
		0x19, 0x6A, 0xF3, 0x57, 0xF7, 0x9F, 0xF9, 0xE7, 0x8C, 0xA6, 0x94, 0x89, 0x76, 0xCD, 0xA8, 0xDA,
		0x72, 0x43, 0x32, 0xA7, 0x56, 0x4F, 0xBF, 0x87
	};

	uint8_t wrapped_key_keys[0x28] =
	{
		0xA6, 0x74, 0x97, 0xBF, 0x76, 0xDA, 0xA2, 0xD0, 0x8D, 0xEB, 0x02, 0x8F, 0x37, 0x93, 0xF4, 0x07,
		0xF4, 0xAC, 0x6F, 0x8C, 0xA8, 0xF8, 0xA0, 0x98, 0x89, 0x93, 0x9A, 0x59, 0xAB, 0x2E, 0xF7, 0x33,
		0x80, 0x57, 0x87, 0x95, 0x32, 0x14, 0xAE, 0x84
	};

	uint8_t salt[0x10] = { 0x35, 0x7C, 0xF8, 0xC2, 0xC2, 0xB3, 0xA5, 0x40, 0xB6, 0x0A, 0xB7, 0x64, 0x18, 0x7F, 0x83, 0xCD };
	int iterations = 100000;
	const uint8_t *pw = reinterpret_cast<const uint8_t *>("Test123");
	size_t pw_len = 7;
	uint8_t dk[0x20];
	uint8_t key_scer_dec[0x28];
	uint8_t key_keys_dec[0x28];
	uint64_t iv;

	PBKDF2_HMAC_SHA256(pw, pw_len, salt, sizeof(salt), iterations, dk, 0x20);
	Rfc3394_KeyUnwrap(key_scer_dec, wrapped_key_scer, 0x20, dk, AES::AES_256, &iv);

	std::cout << "Derived Key:" << std::endl;
	DumpHex(std::cout, dk, 0x20, 0x20);
	std::cout << "Decoded Key:" << std::endl;
	DumpHex(std::cout, key_scer_dec, 0x20, 0x20);
	std::cout << "IV: " << std::hex << iv << std::endl;

	Rfc3394_KeyUnwrap(key_keys_dec, wrapped_key_keys, 0x20, key_scer_dec, AES::AES_256, &iv);

	std::cout << "Decoded Key:" << std::endl;
	DumpHex(std::cout, key_keys_dec, 0x20, 0x20);
	std::cout << "IV: " << std::hex << iv << std::endl;
}

void TestWrapUnwrap()
{
	uint8_t kek[0x10] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F };
	// uint8_t kek[0x10] = { 0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00 };
	// uint64_t plain[2] = { 0x0011223344556677, 0x8899AABBCCDDEEFF };
	uint8_t plain[0x10] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF };
	uint8_t crypt[0x18];
	uint8_t dec[0x10];
	uint64_t iv;

	Rfc3394_KeyWrap(crypt, plain, 0x10, kek, AES::AES_128, 0xA6A6A6A6A6A6A6A6);

	// Should be: 1FA68B0A8112B447 AEF34BD8FB5A7B82 9D3E862371D2CFE5

	DumpHex(std::cout, crypt, 0x18, 0x08);

	Rfc3394_KeyUnwrap(dec, crypt, 0x10, kek, AES::AES_128, &iv);

	DumpHex(std::cout, dec, 0x10, 0x08);

	std::cout << std::hex << "IV: " << iv << std::endl;
}

int main(int argc, char *argv[])
{
	// return TestDiskDecrypt(argc, argv);
	TestBlobVerify();
	TestKeyDerivation();
	TestWrapUnwrap();

	return 0;
}
